### [CVE-2023-6245](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-6245)
![](https://img.shields.io/static/v1?label=Product&message=Candid&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=0.9.0%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=CWE-1288%20Improper%20Validation%20of%20Consistency%20within%20Input&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=CWE-168%20Improper%20Handling%20of%20Inconsistent%20Special%20Elements&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=CWE-20%20Improper%20Input%20Validation&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=CWE-835%20Loop%20with%20Unreachable%20Exit%20Condition%20('Infinite%20Loop')&color=brightgreen)

### Description

The Candid library causes a Denial of Service while parsing a specially crafted payload with 'empty' data type. For example, if the payload is `record { * ; empty }` and the canister interface expects `record { * }` then the Rust candid decoder treats empty as an extra field required by the type.  The problem with the type empty is that the candid Rust library wrongly categorizes empty as a recoverable error when skipping the field and thus causing an infinite decoding loop.Canisters using affected versions of candid are exposed to denial of service by causing the decoding to run indefinitely until the canister traps due to reaching maximum instruction limit per execution round. Repeated exposure to the payload will result in degraded performance of the canister. Note: Canisters written in Motoko are unaffected.

### POC

#### Reference
- https://internetcomputer.org/docs/current/references/candid-ref

#### Github
No PoCs found on GitHub currently.

