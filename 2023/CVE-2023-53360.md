### [CVE-2023-53360](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-53360)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.4%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=886959f425b6a936a30b82a297ae3aecb3b8230f%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=fbd2a05f29a95d5b42b294bf47e55a711424965b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:NFSv4.2: Rework scratch handling for READ_PLUS (again)I found that the read code might send multiple requests using the samenfs_pgio_header, but nfs4_proc_read_setup() is only called once. This ishow we ended up occasionally double-freeing the scratch buffer, but alsomeans we set a NULL pointer but non-zero length to the xdr scratchbuffer. This results in an oops the first time decoding needs to copysomething to scratch, which frequently happens when decoding READ_PLUShole segments.I fix this by moving scratch handling into the pageio read code. Iprovide a function to allocate scratch space for decoding read replies,and free the scratch buffer when the nfs_pgio_header is freed.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds

