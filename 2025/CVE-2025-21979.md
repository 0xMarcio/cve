### [CVE-2025-21979](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-21979)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=3fcc6d7d5f40dad56dee7bde787b7e23edd4b93c%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.5%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=a3ee4dc84c4e9d14cb34dad095fd678127aca5b6%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:wifi: cfg80211: cancel wiphy_work before freeing wiphyA wiphy_work can be queued from the moment the wiphy is allocated andinitialized (i.e. wiphy_new_nm). When a wiphy_work is queued, therdev::wiphy_work is getting queued.If wiphy_free is called before the rdev::wiphy_work had a chance to run,the wiphy memory will be freed, and then when it eventally gets to runit'll use invalid memory.Fix this by canceling the work before freeing the wiphy.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/runwhen-contrib/helm-charts
- https://github.com/w4zu/Debian_security

