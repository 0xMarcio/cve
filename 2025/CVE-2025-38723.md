### [CVE-2025-38723](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38723)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5dc615520c4dfb358245680f1904bad61116648e%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.1%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:LoongArch: BPF: Fix jump offset calculation in tailcallThe extra pass of bpf_int_jit_compile() skips JIT context initializationwhich essentially skips offset calculation leaving out_offset = -1, sothe jmp_offset in emit_bpf_tail_call is calculated by"#define jmp_offset (out_offset - (cur_offset))"is a negative number, which is wrong. The final generated assembly areas follow.54:	bgeu        	$a2, $t1, -8	    # 0x0000004c58:	addi.d      	$a6, $s5, -15c:	bltz        	$a6, -16	    # 0x0000004c60:	alsl.d      	$t2, $a2, $a1, 0x364:	ld.d        	$t2, $t2, 26468:	beq         	$t2, $zero, -28	    # 0x0000004cBefore apply this patch, the follow test case will reveal soft lock issues.cd tools/testing/selftests/bpf/./test_progs --allow=tailcalls/tailcall_bpf2bpf_1dmesg:watchdog: BUG: soft lockup - CPU#2 stuck for 26s! [test_progs:25056]

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

