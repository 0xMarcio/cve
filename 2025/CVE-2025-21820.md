### [CVE-2025-21820](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-21820)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.6%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=74ea66d4ca061a3cd4c0e924e51b60e924644852%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:tty: xilinx_uartps: split sysrq handlinglockdep detects the following circular locking dependency:CPU 0                      CPU 1========================== ============================cdns_uart_isr()            printk()  uart_port_lock(port)       console_lock()			     cdns_uart_console_write()                               if (!port->sysrq)                                 uart_port_lock(port)  uart_handle_break()    port->sysrq = ...  uart_handle_sysrq_char()    printk()      console_lock()The fixed commit attempts to avoid this situation by only taking theport lock in cdns_uart_console_write if port->sysrq unset. However, if(as shown above) cdns_uart_console_write runs before port->sysrq is set,then it will try to take the port lock anyway. This may result in adeadlock.Fix this by splitting sysrq handling into two parts. We use the preparehelper under the port lock and defer handling until we release the lock.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

