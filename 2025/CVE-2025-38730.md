### [CVE-2025-38730](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38730)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.4%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=c56e022c0a27142b7b59ae6bdf45f86bf4b298a1%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:io_uring/net: commit partial buffers on retryRing provided buffers are potentially only valid within the singleexecution context in which they were acquired. io_uring deals with thisand invalidates them on retry. But on the networking side, ifMSG_WAITALL is set, or if the socket is of the streaming type and toolittle was processed, then it will hang on to the buffer rather thanrecycle or commit it. This is problematic for two reasons:1) If someone unregisters the provided buffer ring before a later retry,   then the req->buf_list will no longer be valid.2) If multiple sockers are using the same buffer group, then multiple   receives can consume the same memory. This can cause data corruption   in the application, as either receive could land in the same   userspace buffer.Fix this by disallowing partial retries from pinning a provided bufferacross multiple executions, if ring provided buffers are used.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

