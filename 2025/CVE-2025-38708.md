### [CVE-2025-38708](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38708)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:drbd: add missing kref_get in handle_write_conflictsWith `two-primaries` enabled, DRBD tries to detect "concurrent" writesand handle write conflicts, so that even if you write to the same sectorsimultaneously on both nodes, they end up with the identical data oncethe writes are completed.In handling "superseeded" writes, we forgot a kref_get,resulting in a premature drbd_destroy_device and use after free,and further to kernel crashes with symptoms.Relevance: No one should use DRBD as a random data generator, and apparentlyall users of "two-primaries" handle concurrent writes correctly on layer up.That is cluster file systems use some distributed lock manager,and live migration in virtualization environments stops writes on one nodebefore starting writes on the other node.Which means that other than for "test cases",this code path is never taken in real life.FYI, in DRBD 9, things are handled differently nowadays.  We still detect"write conflicts", but no longer try to be smart about them.We decided to disconnect hard instead: upper layers must not submit concurrentwrites. If they do, that's their fault.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

