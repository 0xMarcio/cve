### [CVE-2025-22058](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-22058)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.10%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=f970bd9e3a06f06df8d8ecf1f8ad2c8615cc17eb%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:udp: Fix memory accounting leak.Matt Dowling reported a weird UDP memory usage issue.Under normal operation, the UDP memory usage reported in /proc/net/sockstatremains close to zero.  However, it occasionally spiked to 524,288 pagesand never dropped.  Moreover, the value doubled when the application wasterminated.  Finally, it caused intermittent packet drops.We can reproduce the issue with the script below [0]:  1. /proc/net/sockstat reports 0 pages    # cat /proc/net/sockstat | grep UDP:    UDP: inuse 1 mem 0  2. Run the script till the report reaches 524,288    # python3 test.py & sleep 5    # cat /proc/net/sockstat | grep UDP:    UDP: inuse 3 mem 524288  <-- (INT_MAX + 1) >> PAGE_SHIFT  3. Kill the socket and confirm the number never drops    # pkill python3 && sleep 5    # cat /proc/net/sockstat | grep UDP:    UDP: inuse 1 mem 524288  4. (necessary since v6.0) Trigger proto_memory_pcpu_drain()    # python3 test.py & sleep 1 && pkill python3  5. The number doubles    # cat /proc/net/sockstat | grep UDP:    UDP: inuse 1 mem 1048577The application set INT_MAX to SO_RCVBUF, which triggered an integeroverflow in udp_rmem_release().When a socket is close()d, udp_destruct_common() purges its receivequeue and sums up skb->truesize in the queue.  This total is calculatedand stored in a local unsigned integer variable.The total size is then passed to udp_rmem_release() to adjust memoryaccounting.  However, because the function takes a signed integerargument, the total size can wrap around, causing an overflow.Then, the released amount is calculated as follows:  1) Add size to sk->sk_forward_alloc.  2) Round down sk->sk_forward_alloc to the nearest lower multiple of      PAGE_SIZE and assign it to amount.  3) Subtract amount from sk->sk_forward_alloc.  4) Pass amount >> PAGE_SHIFT to __sk_mem_reduce_allocated().When the issue occurred, the total in udp_destruct_common() was 2147484480(INT_MAX + 833), which was cast to -2147482816 in udp_rmem_release().At 1) sk->sk_forward_alloc is changed from 3264 to -2147479552, and2) sets -2147479552 to amount.  3) reverts the wraparound, so we don'tsee a warning in inet_sock_destruct().  However, udp_memory_allocatedends up doubling at 4).Since commit 3cd3399dd7a8 ("net: implement per-cpu reserves formemory_allocated"), memory usage no longer doubles immediately aftera socket is close()d because __sk_mem_reduce_allocated() caches theamount in udp_memory_per_cpu_fw_alloc.  However, the next time a UDPsocket receives a packet, the subtraction takes effect, causing UDPmemory usage to double.This issue makes further memory allocation fail once the socket'ssk->sk_rmem_alloc exceeds net.ipv4.udp_rmem_min, resulting in packetdrops.To prevent this issue, let's use unsigned int for the calculation andcall sk_forward_alloc_add() only once for the small delta.Note that first_packet_length() also potentially has the same problem.[0]:from socket import *SO_RCVBUFFORCE = 33INT_MAX = (2 ** 31) - 1s = socket(AF_INET, SOCK_DGRAM)s.bind(('', 0))s.setsockopt(SOL_SOCKET, SO_RCVBUFFORCE, INT_MAX)c = socket(AF_INET, SOCK_DGRAM)c.connect(s.getsockname())data = b'a' * 100while True:    c.send(data)

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/runwhen-contrib/helm-charts
- https://github.com/w4zu/Debian_security

