### [CVE-2025-38350](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38350)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=1034e3310752e8675e313f7271b348914008719a%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=3f3a22eebbc32b4fa8ce9c1d5f9db214b45b9335%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=3f981138109f63232a5fb7165938d4c945cc1b9d%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=49b21795b8e5654a7df3d910a12e1060da4c04cf%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.15%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=89c301e929a0db14ebd94b4d97764ce1d6981653%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=93c276942e75de0e5bc91576300d292e968f5a02%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=f1dde3eb17dc1b8bd07aed00004b1e05fc87a3d4%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=f9f593e34d2fb67644372c8f7b033bdc622ad228%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:net/sched: Always pass notifications when child class becomes emptyCertain classful qdiscs may invoke their classes' dequeue handler on anenqueue operation. This may unexpectedly empty the child qdisc and thusmake an in-flight class passive via qlen_notify(). Most qdiscs do notexpect such behaviour at this point in time and may re-activate theclass eventually anyways which will lead to a use-after-free.The referenced fix commit attempted to fix this behavior for the HFSCcase by moving the backlog accounting around, though this turned out tobe incomplete since the parent's parent may run into the issue too.The following reproducer demonstrates this use-after-free:    tc qdisc add dev lo root handle 1: drr    tc filter add dev lo parent 1: basic classid 1:1    tc class add dev lo parent 1: classid 1:1 drr    tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1    tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0    tc qdisc add dev lo parent 2:1 handle 3: netem    tc qdisc add dev lo parent 3:1 handle 4: blackhole    echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888    tc class delete dev lo classid 1:1    echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888Since backlog accounting issues leading to a use-after-frees on staleclass pointers is a recurring pattern at this point, this patch takesa different approach. Instead of trying to fix the accounting, the patchensures that qdisc_tree_reduce_backlog always calls qlen_notify whenthe child qdisc is empty. This solves the problem because deletion ofqdiscs always involves a call to qdisc_reset() and / orqdisc_purge_queue() which ultimately resets its qlen to 0 thus causingthe following qdisc_tree_reduce_backlog() to report to the parent. Notethat this may call qlen_notify on passive classes multiple times. Thisis not a problem after the recent patch series that made all theclassful qdiscs qlen_notify() handlers idempotent.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

