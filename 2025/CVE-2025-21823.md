### [CVE-2025-21823](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-21823)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.6%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=c833484e5f3872a38fe232c663586069d5ad9645%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:batman-adv: Drop unmanaged ELP metric workerThe ELP worker needs to calculate new metric values for all neighbors"reachable" over an interface. Some of the used metric sources requirelocks which might need to sleep. This sleep is incompatible with the RCUlist iterator used for the recorded neighbors. The initial approach to workaround of this problem was to queue another work item per neighbor and thenrun this in a new context.Even when this solved the RCU vs might_sleep() conflict, it has a majorproblems: Nothing was stopping the work item in case it is not neededanymore - for example because one of the related interfaces was removed orthe batman-adv module was unloaded - resulting in potential invalid memoryaccesses.Directly canceling the metric worker also has various problems:* cancel_work_sync for a to-be-deactivated interface is called with  rtnl_lock held. But the code in the ELP metric worker also tries to use  rtnl_lock() - which will never return in this case. This also means that  cancel_work_sync would never return because it is waiting for the worker  to finish.* iterating over the neighbor list for the to-be-deactivated interface is  currently done using the RCU specific methods. Which means that it is  possible to miss items when iterating over it without the associated  spinlock - a behaviour which is acceptable for a periodic metric check  but not for a cleanup routine (which must "stop" all still running  workers)The better approch is to get rid of the per interface neighbor metricworker and handle everything in the interface worker. The original problemsare solved by:* creating a list of neighbors which require new metric information inside  the RCU protected context, gathering the metric according to the new list  outside the RCU protected context* only use rcu_trylock inside metric gathering code to avoid a deadlock  when the cancel_delayed_work_sync is called in the interface removal code  (which is called with the rtnl_lock held)

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

