### [CVE-2025-38468](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38468)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=2.6.29%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=512bb43eb5422ee69a1be05ea0d89dc074fac9a2%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:net/sched: Return NULL when htb_lookup_leaf encounters an empty rbtreehtb_lookup_leaf has a BUG_ON that can trigger with the following:tc qdisc del dev lo roottc qdisc add dev lo root handle 1: htb default 1tc class add dev lo parent 1: classid 1:1 htb rate 64bittc qdisc add dev lo parent 1:1 handle 2: netemtc qdisc add dev lo parent 2:1 handle 3: blackholeping -I lo -c1 -W0.001 127.0.0.1The root cause is the following:1. htb_dequeue calls htb_dequeue_tree which calls the dequeue handler on   the selected leaf qdisc2. netem_dequeue calls enqueue on the child qdisc3. blackhole_enqueue drops the packet and returns a value that is not   just NET_XMIT_SUCCESS4. Because of this, netem_dequeue calls qdisc_tree_reduce_backlog, and   since qlen is now 0, it calls htb_qlen_notify -> htb_deactivate ->   htb_deactiviate_prios -> htb_remove_class_from_row -> htb_safe_rb_erase5. As this is the only class in the selected hprio rbtree,   __rb_change_child in __rb_erase_augmented sets the rb_root pointer to   NULL6. Because blackhole_dequeue returns NULL, netem_dequeue returns NULL,   which causes htb_dequeue_tree to call htb_lookup_leaf with the same   hprio rbtree, and fail the BUG_ONThe function graph for this scenario is shown here: 0)               |  htb_enqueue() { 0) + 13.635 us   |    netem_enqueue(); 0)   4.719 us    |    htb_activate_prios(); 0) # 2249.199 us |  } 0)               |  htb_dequeue() { 0)   2.355 us    |    htb_lookup_leaf(); 0)               |    netem_dequeue() { 0) + 11.061 us   |      blackhole_enqueue(); 0)               |      qdisc_tree_reduce_backlog() { 0)               |        qdisc_lookup_rcu() { 0)   1.873 us    |          qdisc_match_from_root(); 0)   6.292 us    |        } 0)   1.894 us    |        htb_search(); 0)               |        htb_qlen_notify() { 0)   2.655 us    |          htb_deactivate_prios(); 0)   6.933 us    |        } 0) + 25.227 us   |      } 0)   1.983 us    |      blackhole_dequeue(); 0) + 86.553 us   |    } 0) # 2932.761 us |    qdisc_warn_nonwc(); 0)               |    htb_lookup_leaf() { 0)               |      BUG_ON(); ------------------------------------------The full original bug report can be seen here [1].We can fix this just by returning NULL instead of the BUG_ON,as htb_dequeue_tree returns NULL when htb_lookup_leaf returnsNULL.[1] https://lore.kernel.org/netdev/pF5XOOIim0IuEfhI-SOxTgRvNoDwuux7UHKnE_Y5-zVd4wmGvNk2ceHjKb8ORnzw0cGwfmVu42g9dL7XyJLf1NEzaztboTWcm0Ogxuojoeo=@willsroot.io/

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

