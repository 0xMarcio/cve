### [CVE-2025-38086](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38086)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.3%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4a476bd6d1d923922ec950ddc4c27b279f6901eb%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:net: ch9200: fix uninitialised access during mii_nway_restartIn mii_nway_restart() the code attempts to callmii->mdio_read which is ch9200_mdio_read(). ch9200_mdio_read()utilises a local buffer called "buff", which is initialisedwith control_read(). However "buff" is conditionallyinitialised inside control_read():        if (err == size) {                memcpy(data, buf, size);        }If the condition of "err == size" is not met, then"buff" remains uninitialised. Once this happens theuninitialised "buff" is accessed and returned duringch9200_mdio_read():        return (buff[0] | buff[1] << 8);The problem stems from the fact that ch9200_mdio_read()ignores the return value of control_read(), leading touinit-access of "buff".To fix this we should check the return value ofcontrol_read() and return early on error.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

