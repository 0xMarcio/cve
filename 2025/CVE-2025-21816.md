### [CVE-2025-21816](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-21816)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=53f408cad05bb987af860af22f4151e5a18e6ee8%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=54d0d83a53508d687fd4a225f8aa1f18559562d0%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5c0930ccaad5a74d74e8b18b648c5eb21ed2fe94%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.7%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6fcbcc6c8e52650749692c7613cbe71bf601670d%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=75b5016ce325f1ef9c63e5398a1064cf8a7a7354%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=7f4c89400d2997939f6971c7981cc780a219e36b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=9a2fc41acb69dd4e2a58d0c04346c3333c2341fc%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:hrtimers: Force migrate away hrtimers queued after CPUHP_AP_HRTIMERS_DYINGhrtimers are migrated away from the dying CPU to any online target atthe CPUHP_AP_HRTIMERS_DYING stage in order not to delay bandwidth timershandling tasks involved in the CPU hotplug forward progress.However wakeups can still be performed by the outgoing CPU afterCPUHP_AP_HRTIMERS_DYING. Those can result again in bandwidth timers beingarmed. Depending on several considerations (crystal ball power managementbased election, earliest timer already enqueued, timer migration enabled ornot), the target may eventually be the current CPU even if offline. If thathappens, the timer is eventually ignored.The most notable example is RCU which had to deal with each and every ofthose wake-ups by deferring them to an online CPU, along with relatedworkarounds:_ e787644caf76 (rcu: Defer RCU kthreads wakeup when CPU is dying)_ 9139f93209d1 (rcu/nocb: Fix RT throttling hrtimer armed from offline CPU)_ f7345ccc62a4 (rcu/nocb: Fix rcuog wake-up from offline softirq)The problem isn't confined to RCU though as the stop machine kthread(which runs CPUHP_AP_HRTIMERS_DYING) reports its completion at the endof its work through cpu_stop_signal_done() and performs a wake up thateventually arms the deadline server timer:   WARNING: CPU: 94 PID: 588 at kernel/time/hrtimer.c:1086 hrtimer_start_range_ns+0x289/0x2d0   CPU: 94 UID: 0 PID: 588 Comm: migration/94 Not tainted   Stopper: multi_cpu_stop+0x0/0x120 <- stop_machine_cpuslocked+0x66/0xc0   RIP: 0010:hrtimer_start_range_ns+0x289/0x2d0   Call Trace:   <TASK>     start_dl_timer     enqueue_dl_entity     dl_server_start     enqueue_task_fair     enqueue_task     ttwu_do_activate     try_to_wake_up     complete     cpu_stopper_threadInstead of providing yet another bandaid to work around the situation, fixit in the hrtimers infrastructure instead: always migrate away a timer toan online target whenever it is enqueued from an offline CPU.This will also allow to revert all the above RCU disgraceful hacks.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds
- https://github.com/w4zu/Debian_security

