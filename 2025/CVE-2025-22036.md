### [CVE-2025-22036](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-22036)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=11a347fb6cef62ce47e84b97c45f2b2497c7593b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.8%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:exfat: fix random stack corruption after get_blockWhen get_block is called with a buffer_head allocated on the stack, suchas do_mpage_readpage, stack corruption due to buffer_head UAF may occur inthe following race condition situation.     <CPU 0>                      <CPU 1>mpage_read_folio  <<bh on stack>>  do_mpage_readpage    exfat_get_block      bh_read        __bh_read	  get_bh(bh)          submit_bh          wait_on_buffer                              ...                              end_buffer_read_sync                                __end_buffer_read_notouch                                   unlock_buffer          <<keep going>>        ...      ...    ...  ...<<bh is not valid out of mpage_read_folio>>   .   .another_function  <<variable A on stack>>                                   put_bh(bh)                                     atomic_dec(bh->b_count)  * stack corruption here *This patch returns -EAGAIN if a folio does not have buffers when bh_readneeds to be called. By doing this, the caller can fallback to functionslike block_read_full_folio(), create a buffer_head in the folio, and thencall get_block again.Let's do not call bh_read() with on-stack buffer_head.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/ARPSyndicate/cve-scores

