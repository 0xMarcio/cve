### [CVE-2025-37893](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-37893)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5dc615520c4dfb358245680f1904bad61116648e%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.1%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:LoongArch: BPF: Fix off-by-one error in build_prologue()Vincent reported that running BPF progs with tailcalls on LoongArchcauses kernel hard lockup. Debugging the issues shows that the JITedimage missing a jirl instruction at the end of the epilogue.There are two passes in JIT compiling, the first pass set the flags andthe second pass generates JIT code based on those flags. With BPF progsmixing bpf2bpf and tailcalls, build_prologue() generates N insns in thefirst pass and then generates N+1 insns in the second pass. This makesepilogue_offset off by one and we will jump to some unexpected insn andcause lockup. Fix this by inserting a nop insn.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds

