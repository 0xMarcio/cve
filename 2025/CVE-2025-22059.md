### [CVE-2025-22059](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-22059)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.10%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6a1f12dd85a8b24f871dfcf467378660af9c064d%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:udp: Fix multiple wraparounds of sk->sk_rmem_alloc.__udp_enqueue_schedule_skb() has the following condition:  if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)          goto drop;sk->sk_rcvbuf is initialised by net.core.rmem_default and later canbe configured by SO_RCVBUF, which is limited by net.core.rmem_max,or SO_RCVBUFFORCE.If we set INT_MAX to sk->sk_rcvbuf, the condition is always falseas sk->sk_rmem_alloc is also signed int.Then, the size of the incoming skb is added to sk->sk_rmem_allocunconditionally.This results in integer overflow (possibly multiple times) onsk->sk_rmem_alloc and allows a single socket to have skb up tonet.core.udp_mem[1].For example, if we set a large value to udp_mem[1] and INT_MAX tosk->sk_rcvbuf and flood packets to the socket, we can see multipleoverflows:  # cat /proc/net/sockstat | grep UDP:  UDP: inuse 3 mem 7956736  <-- (7956736 << 12) bytes > INT_MAX * 15                                             ^- PAGE_SHIFT  # ss -uam  State  Recv-Q      ...  UNCONN -1757018048 ...    <-- flipping the sign repeatedly         skmem:(r2537949248,rb2147483646,t0,tb212992,f1984,w0,o0,bl0,d0)Previously, we had a boundary check for INT_MAX, which was removed bycommit 6a1f12dd85a8 ("udp: relax atomic operation on sk->sk_rmem_alloc").A complete fix would be to revert it and cap the right operand byINT_MAX:  rmem = atomic_add_return(size, &sk->sk_rmem_alloc);  if (rmem > min(size + (unsigned int)sk->sk_rcvbuf, INT_MAX))          goto uncharge_drop;but we do not want to add the expensive atomic_add_return() back justfor the corner case.Casting rmem to unsigned int prevents multiple wraparounds, but we stillallow a single wraparound.  # cat /proc/net/sockstat | grep UDP:  UDP: inuse 3 mem 524288  <-- (INT_MAX + 1) >> 12  # ss -uam  State  Recv-Q      ...  UNCONN -2147482816 ...   <-- INT_MAX + 831 bytes         skmem:(r2147484480,rb2147483646,t0,tb212992,f3264,w0,o0,bl0,d14468947)So, let's define rmem and rcvbuf as unsigned int and check skb->truesizeonly when rcvbuf is large enough to lower the overflow possibility.Note that we still have a small chance to see overflow if multiple skbsto the same socket are processed on different core at the same time andeach size does not exceed the limit but the total size does.Note also that we must ignore skb->truesize for a small buffer asexplained in commit 363dc73acacb ("udp: be less conservative withsock rmem accounting").

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/ARPSyndicate/cve-scores

