### [CVE-2025-21722](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-21722)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=3.10%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=8c26c4e2694a163d525976e804d81cd955bbb40c%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:nilfs2: do not force clear folio if buffer is referencedPatch series "nilfs2: protect busy buffer heads from being force-cleared".This series fixes the buffer head state inconsistency issues reported bysyzbot that occurs when the filesystem is corrupted and falls back toread-only, and the associated buffer head use-after-free issue.This patch (of 2):Syzbot has reported that after nilfs2 detects filesystem corruption andfalls back to read-only, inconsistencies in the buffer state may occur.One of the inconsistencies is that when nilfs2 calls mark_buffer_dirty()to set a data or metadata buffer as dirty, but it detects that the bufferis not in the uptodate state: WARNING: CPU: 0 PID: 6049 at fs/buffer.c:1177 mark_buffer_dirty+0x2e5/0x520  fs/buffer.c:1177 ... Call Trace:  <TASK>  nilfs_palloc_commit_alloc_entry+0x4b/0x160 fs/nilfs2/alloc.c:598  nilfs_ifile_create_inode+0x1dd/0x3a0 fs/nilfs2/ifile.c:73  nilfs_new_inode+0x254/0x830 fs/nilfs2/inode.c:344  nilfs_mkdir+0x10d/0x340 fs/nilfs2/namei.c:218  vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257  do_mkdirat+0x264/0x3a0 fs/namei.c:4280  __do_sys_mkdirat fs/namei.c:4295 [inline]  __se_sys_mkdirat fs/namei.c:4293 [inline]  __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293  do_syscall_x64 arch/x86/entry/common.c:52 [inline]  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x77/0x7fThe other is when nilfs_btree_propagate(), which propagates the dirtystate to the ancestor nodes of a b-tree that point to a dirty buffer,detects that the origin buffer is not dirty, even though it should be: WARNING: CPU: 0 PID: 5245 at fs/nilfs2/btree.c:2089  nilfs_btree_propagate+0xc79/0xdf0 fs/nilfs2/btree.c:2089 ... Call Trace:  <TASK>  nilfs_bmap_propagate+0x75/0x120 fs/nilfs2/bmap.c:345  nilfs_collect_file_data+0x4d/0xd0 fs/nilfs2/segment.c:587  nilfs_segctor_apply_buffers+0x184/0x340 fs/nilfs2/segment.c:1006  nilfs_segctor_scan_file+0x28c/0xa50 fs/nilfs2/segment.c:1045  nilfs_segctor_collect_blocks fs/nilfs2/segment.c:1216 [inline]  nilfs_segctor_collect fs/nilfs2/segment.c:1540 [inline]  nilfs_segctor_do_construct+0x1c28/0x6b90 fs/nilfs2/segment.c:2115  nilfs_segctor_construct+0x181/0x6b0 fs/nilfs2/segment.c:2479  nilfs_segctor_thread_construct fs/nilfs2/segment.c:2587 [inline]  nilfs_segctor_thread+0x69e/0xe80 fs/nilfs2/segment.c:2701  kthread+0x2f0/0x390 kernel/kthread.c:389  ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  </TASK>Both of these issues are caused by the callbacks that handle thepage/folio write requests, forcibly clear various states, including theworking state of the buffers they hold, at unexpected times when theydetect read-only fallback.Fix these issues by checking if the buffer is referenced before clearingthe page/folio state, and skipping the clear if it is.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

