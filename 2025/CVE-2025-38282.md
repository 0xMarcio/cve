### [CVE-2025-38282](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38282)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.1%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=bdb2fd7fc56e197a63c0b0e7e07d25d5e20e7c72%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:kernfs: Relax constraint in draining guardThe active reference lifecycle provides the break/unbreak mechanism butthe active reference is not truly active after unbreak -- callers don'tuse it afterwards but it's important for proper pairing of kn->activecounting. Assuming this mechanism is in place, the WARN check inkernfs_should_drain_open_files() is too sensitive -- it may transientlycatch those (rightful) callers betweenkernfs_unbreak_active_protection() and kernfs_put_active() as found out by ChenRidong:	kernfs_remove_by_name_ns	kernfs_get_active // active=1	__kernfs_remove					  // active=0x80000002	kernfs_drain			...	wait_event	//waiting (active == 0x80000001)					kernfs_break_active_protection					// active = 0x80000001	// continue					kernfs_unbreak_active_protection					// active = 0x80000002	...	kernfs_should_drain_open_files	// warning occurs					kernfs_put_activeTo avoid the false positives (mind panic_on_warn) remove the check altogether.(This is meant as quick fix, I think active reference break/unbreak may besimplified with larger rework.)

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

