### [CVE-2025-38365](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38365)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=259c4b96d78dda8477a3ac21d6b3cf0eb9f75c8b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5.18%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:btrfs: fix a race between renames and directory loggingWe have a race between a rename and directory inode logging that if ithappens and we crash/power fail before the rename completes, the next timethe filesystem is mounted, the log replay code will end up deleting thefile that was being renamed.This is best explained following a step by step analysis of an interleavingof steps that lead into this situation.Consider the initial conditions:1) We are at transaction N;2) We have directories A and B created in a past transaction (< N);3) We have inode X corresponding to a file that has 2 hardlinks, one in   directory A and the other in directory B, so we'll name them as   "A/foo_link1" and "B/foo_link2". Both hard links were persisted in a   past transaction (< N);4) We have inode Y corresponding to a file that as a single hard link and   is located in directory A, we'll name it as "A/bar". This file was also   persisted in a past transaction (< N).The steps leading to a file loss are the following and for all of them weare under transaction N: 1) Link "A/foo_link1" is removed, so inode's X last_unlink_trans field    is updated to N, through btrfs_unlink() -> btrfs_record_unlink_dir(); 2) Task A starts a rename for inode Y, with the goal of renaming from    "A/bar" to "A/baz", so we enter btrfs_rename(); 3) Task A inserts the new BTRFS_INODE_REF_KEY for inode Y by calling    btrfs_insert_inode_ref(); 4) Because the rename happens in the same directory, we don't set the    last_unlink_trans field of directoty A's inode to the current    transaction id, that is, we don't cal btrfs_record_unlink_dir(); 5) Task A then removes the entries from directory A (BTRFS_DIR_ITEM_KEY    and BTRFS_DIR_INDEX_KEY items) when calling __btrfs_unlink_inode()    (actually the dir index item is added as a delayed item, but the    effect is the same); 6) Now before task A adds the new entry "A/baz" to directory A by    calling btrfs_add_link(), another task, task B is logging inode X; 7) Task B starts a fsync of inode X and after logging inode X, at    btrfs_log_inode_parent() it calls btrfs_log_all_parents(), since    inode X has a last_unlink_trans value of N, set at in step 1; 8) At btrfs_log_all_parents() we search for all parent directories of    inode X using the commit root, so we find directories A and B and log    them. Bu when logging direct A, we don't have a dir index item for    inode Y anymore, neither the old name "A/bar" nor for the new name    "A/baz" since the rename has deleted the old name but has not yet    inserted the new name - task A hasn't called yet btrfs_add_link() to    do that.    Note that logging directory A doesn't fallback to a transaction    commit because its last_unlink_trans has a lower value than the    current transaction's id (see step 4); 9) Task B finishes logging directories A and B and gets back to    btrfs_sync_file() where it calls btrfs_sync_log() to persist the log    tree;10) Task B successfully persisted the log tree, btrfs_sync_log() completed    with success, and a power failure happened.    We have a log tree without any directory entry for inode Y, so the    log replay code deletes the entry for inode Y, name "A/bar", from the    subvolume tree since it doesn't exist in the log tree and the log    tree is authorative for its index (we logged a BTRFS_DIR_LOG_INDEX_KEY    item that covers the index range for the dentry that corresponds to    "A/bar").    Since there's no other hard link for inode Y and the log replay code    deletes the name "A/bar", the file is lost.The issue wouldn't happen if task B synced the log only after task Acalled btrfs_log_new_name(), which would update the log with the new namefor inode Y ("A/bar").Fix this by pinning the log root during renames before removing the olddirectory entry, and unpinning af---truncated---

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

