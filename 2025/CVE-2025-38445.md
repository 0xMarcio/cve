### [CVE-2025-38445](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38445)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.18%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=afeee514ce7f4cab605beedd03be71ebaf0c5fc8%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:md/raid1: Fix stack memory use after return in raid1_reshapeIn the raid1_reshape function, newpool isallocated on the stack and assigned to conf->r1bio_pool.This results in conf->r1bio_pool.wait.head pointingto a stack address.Accessing this address later can lead to a kernel panic.Example access path:raid1_reshape(){	// newpool is on the stack	mempool_t newpool, oldpool;	// initialize newpool.wait.head to stack address	mempool_init(&newpool, ...);	conf->r1bio_pool = newpool;}raid1_read_request() or raid1_write_request(){	alloc_r1bio()	{		mempool_alloc()		{			// if pool->alloc fails			remove_element()			{				--pool->curr_nr;			}		}	}}mempool_free(){	if (pool->curr_nr < pool->min_nr) {		// pool->wait.head is a stack address		// wake_up() will try to access this invalid address		// which leads to a kernel panic		return;		wake_up(&pool->wait);	}}Fix:reinit conf->r1bio_pool.wait after assigning newpool.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

