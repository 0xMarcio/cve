### [CVE-2025-39685](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-39685)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=3.13%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=fff46207245cd9e39c05b638afaee2478e64914b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:comedi: pcl726: Prevent invalid irq numberThe reproducer passed in an irq number(0x80008000) that was too large,which triggered the oob.Added an interrupt number check to prevent users from passing in an irqnumber that was too large.If `it->options[1]` is 31, then `1 << it->options[1]` is still invalidbecause it shifts a 1-bit into the sign bit (which is UB in C).Possible solutions include reducing the upper bound on the`it->options[1]` value to 30 or lower, or using `1U << it->options[1]`.The old code would just not attempt to request the IRQ if the`options[1]` value were invalid.  And it would still configure thedevice without interrupts even if the call to `request_irq` returned anerror.  So it would be better to combine this test with the test below.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

