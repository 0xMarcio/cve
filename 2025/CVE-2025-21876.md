### [CVE-2025-21876](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-21876)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.10%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=d74169ceb0d2e32438946a2f1f9fc8c803304bd6%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:iommu/vt-d: Fix suspicious RCU usageCommit <d74169ceb0d2> ("iommu/vt-d: Allocate DMAR fault interruptslocally") moved the call to enable_drhd_fault_handling() to a codepath that does not hold any lock while traversing the drhd list. Fixit by ensuring the dmar_global_lock lock is held when traversing thedrhd list.Without this fix, the following warning is triggered: ============================= WARNING: suspicious RCU usage 6.14.0-rc3 #55 Not tainted ----------------------------- drivers/iommu/intel/dmar.c:2046 RCU-list traversed in non-reader section!!               other info that might help us debug this:               rcu_scheduler_active = 1, debug_locks = 1 2 locks held by cpuhp/1/23: #0: ffffffff84a67c50 (cpu_hotplug_lock){++++}-{0:0}, at: cpuhp_thread_fun+0x87/0x2c0 #1: ffffffff84a6a380 (cpuhp_state-up){+.+.}-{0:0}, at: cpuhp_thread_fun+0x87/0x2c0 stack backtrace: CPU: 1 UID: 0 PID: 23 Comm: cpuhp/1 Not tainted 6.14.0-rc3 #55 Call Trace:  <TASK>  dump_stack_lvl+0xb7/0xd0  lockdep_rcu_suspicious+0x159/0x1f0  ? __pfx_enable_drhd_fault_handling+0x10/0x10  enable_drhd_fault_handling+0x151/0x180  cpuhp_invoke_callback+0x1df/0x990  cpuhp_thread_fun+0x1ea/0x2c0  smpboot_thread_fn+0x1f5/0x2e0  ? __pfx_smpboot_thread_fn+0x10/0x10  kthread+0x12a/0x2d0  ? __pfx_kthread+0x10/0x10  ret_from_fork+0x4a/0x60  ? __pfx_kthread+0x10/0x10  ret_from_fork_asm+0x1a/0x30  </TASK>Holding the lock in enable_drhd_fault_handling() triggers a lockdep splatabout a possible deadlock between dmar_global_lock and cpu_hotplug_lock.This is avoided by not holding dmar_global_lock when callingiommu_device_register(), which initiates the device probe process.

### POC

#### Reference
- https://git.kernel.org/stable/c/4117c72938493a77ab53cc4b8284be8fb6ec8065

#### Github
No PoCs found on GitHub currently.

