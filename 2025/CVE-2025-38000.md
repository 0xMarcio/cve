### [CVE-2025-38000](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38000)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=12d0ad3be9c3854e52ec74bb83bb6f43612827c7%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.8%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:sch_hfsc: Fix qlen accounting bug when using peek in hfsc_enqueue()When enqueuing the first packet to an HFSC class, hfsc_enqueue() calls thechild qdisc's peek() operation before incrementing sch->q.qlen andsch->qstats.backlog. If the child qdisc uses qdisc_peek_dequeued(), this maytrigger an immediate dequeue and potential packet drop. In such cases,qdisc_tree_reduce_backlog() is called, but the HFSC qdisc's qlen and backloghave not yet been updated, leading to inconsistent queue accounting. Thiscan leave an empty HFSC class in the active list, causing furtherconsequences like use-after-free.This patch fixes the bug by moving the increment of sch->q.qlen andsch->qstats.backlog before the call to the child qdisc's peek() operation.This ensures that queue length and backlog are always accurate when packetdrops or dequeues are triggered during the peek.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

