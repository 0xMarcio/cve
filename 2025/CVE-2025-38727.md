### [CVE-2025-38727](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38727)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4b8e18af7bea92f8b7fb92d40aeae729209db250%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=55baecb9eb90238f60a8350660d6762046ebd3bd%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.16%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=76602d8e13864524382b0687dc32cd8f19164d5a%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=9da025150b7c14a8390fc06aea314c0a4011e82c%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=ae8f160e7eb24240a2a79fc4c815c6a0d4ee16cc%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=c4ceaac5c5ba0b992ee1dc88e2a02421549e5c98%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=cd7ff61bfffd7000143c42bbffb85eeb792466d6%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=fd69af06101090eaa60b3d216ae715f9c0a58e5b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:netlink: avoid infinite retry looping in netlink_unicast()netlink_attachskb() checks for the socket's read memory allocationconstraints. Firstly, it has:  rmem < READ_ONCE(sk->sk_rcvbuf)to check if the just increased rmem value fits into the socket's receivebuffer. If not, it proceeds and tries to wait for the memory under:  rmem + skb->truesize > READ_ONCE(sk->sk_rcvbuf)The checks don't cover the case when skb->truesize + sk->sk_rmem_alloc isequal to sk->sk_rcvbuf. Thus the function neither successfully acceptsthese conditions, nor manages to reschedule the task - and is called inretry loop for indefinite time which is caught as:  rcu: INFO: rcu_sched self-detected stall on CPU  rcu:     0-....: (25999 ticks this GP) idle=ef2/1/0x4000000000000000 softirq=262269/262269 fqs=6212  (t=26000 jiffies g=230833 q=259957)  NMI backtrace for cpu 0  CPU: 0 PID: 22 Comm: kauditd Not tainted 5.10.240 #68  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc42 04/01/2014  Call Trace:  <IRQ>  dump_stack lib/dump_stack.c:120  nmi_cpu_backtrace.cold lib/nmi_backtrace.c:105  nmi_trigger_cpumask_backtrace lib/nmi_backtrace.c:62  rcu_dump_cpu_stacks kernel/rcu/tree_stall.h:335  rcu_sched_clock_irq.cold kernel/rcu/tree.c:2590  update_process_times kernel/time/timer.c:1953  tick_sched_handle kernel/time/tick-sched.c:227  tick_sched_timer kernel/time/tick-sched.c:1399  __hrtimer_run_queues kernel/time/hrtimer.c:1652  hrtimer_interrupt kernel/time/hrtimer.c:1717  __sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1113  asm_call_irq_on_stack arch/x86/entry/entry_64.S:808  </IRQ>  netlink_attachskb net/netlink/af_netlink.c:1234  netlink_unicast net/netlink/af_netlink.c:1349  kauditd_send_queue kernel/audit.c:776  kauditd_thread kernel/audit.c:897  kthread kernel/kthread.c:328  ret_from_fork arch/x86/entry/entry_64.S:304Restore the original behavior of the check which commit in Fixesaccidentally missed when restructuring the code.Found by Linux Verification Center (linuxtesting.org).

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

