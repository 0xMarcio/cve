### [CVE-2025-7394](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-7394)
![](https://img.shields.io/static/v1?label=Product&message=wolfSSL&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=3.15.0%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=CWE-200%20Exposure%20of%20Sensitive%20Information%20to%20an%20Unauthorized%20Actor&color=brightgreen)

### Description

In the OpenSSL compatibility layer implementation, the function RAND_poll() was not behaving as expected and leading to the potential for predictable values returned from RAND_bytes() after fork() is called. This can lead to weak or predictable random numbers generated in applications that are both using RAND_bytes() and doing fork() operations. This only affects applications explicitly calling RAND_bytes() after fork() and does not affect any internal TLS operations. Although RAND_bytes() documentation in OpenSSL calls out not being safe for use with fork() without first calling RAND_poll(), an additional code change was also made in wolfSSL to make RAND_bytes() behave similar to OpenSSL after a fork() call without calling RAND_poll(). Now the Hash-DRBG used gets reseeded after detecting running in a new process. If making use of RAND_bytes() and calling fork() we recommend updating to the latest version of wolfSSL. Thanks to Per Allansson from Appgate for the report.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/17seetwice/wolfssl_mlkem_ascon
- https://github.com/deepin-community/wolfssl
- https://github.com/faojdoai324234s/wolfSSL
- https://github.com/wolfSSL/Arduino-wolfSSL
- https://github.com/wolfSSL/wolfssl

