### [CVE-2025-37957](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-37957)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.1%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6425c590d0cc6914658a630a40b7f8226aa028c3%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=d40ef0a511676bd65ca9acb295430c07af59ab85%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=ed129ec9057f89d615ba0c81a4984a90345a1684%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:KVM: SVM: Forcibly leave SMM mode on SHUTDOWN interceptionPreviously, commit ed129ec9057f ("KVM: x86: forcibly leave nested modeon vCPU reset") addressed an issue where a triple fault occurring innested mode could lead to use-after-free scenarios. However, the commitdid not handle the analogous situation for System Management Mode (SMM).This omission results in triggering a WARN when KVM forces a vCPU INITafter SHUTDOWN interception while the vCPU is in SMM. This situation wasreprodused using Syzkaller by:  1) Creating a KVM VM and vCPU  2) Sending a KVM_SMI ioctl to explicitly enter SMM  3) Executing invalid instructions causing consecutive exceptions and     eventually a triple faultThe issue manifests as follows:  WARNING: CPU: 0 PID: 25506 at arch/x86/kvm/x86.c:12112  kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c:12112  Modules linked in:  CPU: 0 PID: 25506 Comm: syz-executor.0 Not tainted  6.1.130-syzkaller-00157-g164fe5dde9b6 #0  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),  BIOS 1.12.0-1 04/01/2014  RIP: 0010:kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c:12112  Call Trace:   <TASK>   shutdown_interception+0x66/0xb0 arch/x86/kvm/svm/svm.c:2136   svm_invoke_exit_handler+0x110/0x530 arch/x86/kvm/svm/svm.c:3395   svm_handle_exit+0x424/0x920 arch/x86/kvm/svm/svm.c:3457   vcpu_enter_guest arch/x86/kvm/x86.c:10959 [inline]   vcpu_run+0x2c43/0x5a90 arch/x86/kvm/x86.c:11062   kvm_arch_vcpu_ioctl_run+0x50f/0x1cf0 arch/x86/kvm/x86.c:11283   kvm_vcpu_ioctl+0x570/0xf00 arch/x86/kvm/../../../virt/kvm/kvm_main.c:4122   vfs_ioctl fs/ioctl.c:51 [inline]   __do_sys_ioctl fs/ioctl.c:870 [inline]   __se_sys_ioctl fs/ioctl.c:856 [inline]   __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c:856   do_syscall_x64 arch/x86/entry/common.c:51 [inline]   do_syscall_64+0x35/0x80 arch/x86/entry/common.c:81   entry_SYSCALL_64_after_hwframe+0x6e/0xd8Architecturally, INIT is blocked when the CPU is in SMM, hence KVM's WARN()in kvm_vcpu_reset() to guard against KVM bugs, e.g. to detect improperemulation of INIT.  SHUTDOWN on SVM is a weird edge case where KVM needs todo _something_ sane with the VMCB, since it's technically undefined, andINIT is the least awful choice given KVM's ABI.So, double down on stuffing INIT on SHUTDOWN, and force the vCPU out ofSMM to avoid any weirdness (and the WARN).Found by Linux Verification Center (linuxtesting.org) with Syzkaller.[sean: massage changelog, make it clear this isn't architectural behavior]

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds

