### [CVE-2025-38349](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38349)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=58c9b016e12855286370dfb704c08498edbc857a%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.4%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:eventpoll: don't decrement ep refcount while still holding the ep mutexJann Horn points out that epoll is decrementing the ep refcount and thendoing a    mutex_unlock(&ep->mtx);afterwards. That's very wrong, because it can lead to a use-after-free.That pattern is actually fine for the very last reference, because thecode in question will delay the actual call to "ep_free(ep)" until afterit has unlocked the mutex.But it's wrong for the much subtler "next to last" case when somebody*else* may also be dropping their reference and free the ep while we'restill using the mutex.Note that this is true even if that other user is also using the same epmutex: mutexes, unlike spinlocks, can not be used for object ownership,even if they guarantee mutual exclusion.A mutex "unlock" operation is not atomic, and as one user is stillaccessing the mutex as part of unlocking it, another user can come inand get the now released mutex and free the data structure while thefirst user is still cleaning up.See our mutex documentation in Documentation/locking/mutex-design.rst,in particular the section [1] about semantics:	"mutex_unlock() may access the mutex structure even after it has	 internally released the lock already - so it's not safe for	 another context to acquire the mutex and assume that the	 mutex_unlock() context is not using the structure anymore"So if we drop our ep ref before the mutex unlock, but we weren't thelast one, we may then unlock the mutex, another user comes in, drops_their_ reference and releases the 'ep' as it now has no users - allwhile the mutex_unlock() is still accessing it.Fix this by simply moving the ep refcount dropping to outside the mutex:the refcount itself is atomic, and doesn't need mutex protection (that'sthe whole _point_ of refcounts: unlike mutexes, they are inherentlyabout object lifetimes).

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/ARPSyndicate/cve-scores
- https://github.com/w4zu/Debian_security

