### [CVE-2025-39863](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-39863)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=3.10%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=61730d4dfffc2cc9d3a49fad87633008105c18ba%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:wifi: brcmfmac: fix use-after-free when rescheduling brcmf_btcoex_info workThe brcmf_btcoex_detach() only shuts down the btcoex timer, if theflag timer_on is false. However, the brcmf_btcoex_timerfunc(), whichruns as timer handler, sets timer_on to false. This creates criticalrace conditions:1.If brcmf_btcoex_detach() is called while brcmf_btcoex_timerfunc()is executing, it may observe timer_on as false and skip the call totimer_shutdown_sync().2.The brcmf_btcoex_timerfunc() may then reschedule the brcmf_btcoex_infoworker after the cancel_work_sync() has been executed, resulting inuse-after-free bugs.The use-after-free bugs occur in two distinct scenarios, depending onthe timing of when the brcmf_btcoex_info struct is freed relative tothe execution of its worker thread.Scenario 1: Freed before the worker is scheduledThe brcmf_btcoex_info is deallocated before the worker is scheduled.A race condition can occur when schedule_work(&bt_local->work) iscalled after the target memory has been freed. The sequence of eventsis detailed below:CPU0                           | CPU1brcmf_btcoex_detach            | brcmf_btcoex_timerfunc                               |   bt_local->timer_on = false;  if (cfg->btcoex->timer_on)   |    ...                        |  cancel_work_sync();          |  ...                          |  kfree(cfg->btcoex); // FREE  |                               |   schedule_work(&bt_local->work); // USEScenario 2: Freed after the worker is scheduledThe brcmf_btcoex_info is freed after the worker has been scheduledbut before or during its execution. In this case, statements withinthe brcmf_btcoex_handler() â€” such as the container_of macro andsubsequent dereferences of the brcmf_btcoex_info object will causea use-after-free access. The following timeline illustrates thisscenario:CPU0                            | CPU1brcmf_btcoex_detach             | brcmf_btcoex_timerfunc                                |   bt_local->timer_on = false;  if (cfg->btcoex->timer_on)    |    ...                         |  cancel_work_sync();           |  ...                           |   schedule_work(); // Reschedule                                |  kfree(cfg->btcoex); // FREE   |   brcmf_btcoex_handler() // Worker  /*                            |     btci = container_of(....); // USE   The kfree() above could      |     ...   also occur at any point      |     btci-> // USE   during the worker's execution|   */                           |To resolve the race conditions, drop the conditional check and calltimer_shutdown_sync() directly. It can deactivate the timer reliably,regardless of its current state. Once stopped, the timer_on state isthen set to false.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

