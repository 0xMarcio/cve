### [CVE-2025-22126](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-22126)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.0%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=f26514342255855f4ca3c0a92cb1cdea01c33004%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:md: fix mddev uaf while iterating all_mddevs listWhile iterating all_mddevs list from md_notify_reboot() and md_exit(),list_for_each_entry_safe is used, and this can race with deletint thenext mddev, causing UAF:t1:spin_lock//list_for_each_entry_safe(mddev, n, ...) mddev_get(mddev1) // assume mddev2 is the next entry spin_unlock            t2:            //remove mddev2            ...            mddev_free            spin_lock            list_del            spin_unlock            kfree(mddev2) mddev_put(mddev1) spin_lock //continue dereference mddev2->all_mddevsThe old helper for_each_mddev() actually grab the reference of mddev2while holding the lock, to prevent from being freed. This problem can befixed the same way, however, the code will be complex.Hence switch to use list_for_each_entry, in this case mddev_put() can freethe mddev1 and it's not safe as well. Refer to md_seq_show(), also factorout a helper mddev_put_locked() to fix this problem.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds
- https://github.com/w4zu/Debian_security

