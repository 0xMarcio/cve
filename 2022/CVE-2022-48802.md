### [CVE-2022-48802](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-48802)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.5%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=e9b61f19858a5d6c42ce2298cf138279375d0d9b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:fs/proc: task_mmu.c: don't read mapcount for migration entryThe syzbot reported the below BUG:  kernel BUG at include/linux/page-flags.h:785!  invalid opcode: 0000 [#1] PREEMPT SMP KASAN  CPU: 1 PID: 4392 Comm: syz-executor560 Not tainted 5.16.0-rc6-syzkaller #0  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  RIP: 0010:PageDoubleMap include/linux/page-flags.h:785 [inline]  RIP: 0010:__page_mapcount+0x2d2/0x350 mm/util.c:744  Call Trace:    page_mapcount include/linux/mm.h:837 [inline]    smaps_account+0x470/0xb10 fs/proc/task_mmu.c:466    smaps_pte_entry fs/proc/task_mmu.c:538 [inline]    smaps_pte_range+0x611/0x1250 fs/proc/task_mmu.c:601    walk_pmd_range mm/pagewalk.c:128 [inline]    walk_pud_range mm/pagewalk.c:205 [inline]    walk_p4d_range mm/pagewalk.c:240 [inline]    walk_pgd_range mm/pagewalk.c:277 [inline]    __walk_page_range+0xe23/0x1ea0 mm/pagewalk.c:379    walk_page_vma+0x277/0x350 mm/pagewalk.c:530    smap_gather_stats.part.0+0x148/0x260 fs/proc/task_mmu.c:768    smap_gather_stats fs/proc/task_mmu.c:741 [inline]    show_smap+0xc6/0x440 fs/proc/task_mmu.c:822    seq_read_iter+0xbb0/0x1240 fs/seq_file.c:272    seq_read+0x3e0/0x5b0 fs/seq_file.c:162    vfs_read+0x1b5/0x600 fs/read_write.c:479    ksys_read+0x12d/0x250 fs/read_write.c:619    do_syscall_x64 arch/x86/entry/common.c:50 [inline]    do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80    entry_SYSCALL_64_after_hwframe+0x44/0xaeThe reproducer was trying to read /proc/$PID/smaps when callingMADV_FREE at the mean time.  MADV_FREE may split THPs if it is calledfor partial THP.  It may trigger the below race:           CPU A                         CPU B           -----                         -----  smaps walk:                      MADV_FREE:  page_mapcount()    PageCompound()                                   split_huge_page()    page = compound_head(page)    PageDoubleMap(page)When calling PageDoubleMap() this page is not a tail page of THP anymoreso the BUG is triggered.This could be fixed by elevated refcount of the page before callingmapcount, but that would prevent it from counting migration entries, andit seems overkilling because the race just could happen when PMD issplit so all PTE entries of tail pages are actually migration entries,and smaps_account() does treat migration entries as mapcount == 1 asKirill pointed out.Add a new parameter for smaps_account() to tell this entry is migrationentry then skip calling page_mapcount().  Don't skip getting mapcountfor device private entries since they do track references with mapcount.Pagemap also has the similar issue although it was not reported.  Fixedit as well.[shy828301@gmail.com: v4][nathan@kernel.org: avoid unused variable warning in pagemap_pmd_range()]

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds

