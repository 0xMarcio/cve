### [CVE-2022-49985](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-49985)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5.5%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=d2e4c1e6c2947269346054ac8937ccfe9e0bcc6b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:bpf: Don't use tnum_range on array range checking for poke descriptorsHsin-Wei reported a KASAN splat triggered by their BPF runtime fuzzer whichis based on a customized syzkaller:  BUG: KASAN: slab-out-of-bounds in bpf_int_jit_compile+0x1257/0x13f0  Read of size 8 at addr ffff888004e90b58 by task syz-executor.0/1489  CPU: 1 PID: 1489 Comm: syz-executor.0 Not tainted 5.19.0 #1  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS  1.13.0-1ubuntu1.1 04/01/2014  Call Trace:   <TASK>   dump_stack_lvl+0x9c/0xc9   print_address_description.constprop.0+0x1f/0x1f0   ? bpf_int_jit_compile+0x1257/0x13f0   kasan_report.cold+0xeb/0x197   ? kvmalloc_node+0x170/0x200   ? bpf_int_jit_compile+0x1257/0x13f0   bpf_int_jit_compile+0x1257/0x13f0   ? arch_prepare_bpf_dispatcher+0xd0/0xd0   ? rcu_read_lock_sched_held+0x43/0x70   bpf_prog_select_runtime+0x3e8/0x640   ? bpf_obj_name_cpy+0x149/0x1b0   bpf_prog_load+0x102f/0x2220   ? __bpf_prog_put.constprop.0+0x220/0x220   ? find_held_lock+0x2c/0x110   ? __might_fault+0xd6/0x180   ? lock_downgrade+0x6e0/0x6e0   ? lock_is_held_type+0xa6/0x120   ? __might_fault+0x147/0x180   __sys_bpf+0x137b/0x6070   ? bpf_perf_link_attach+0x530/0x530   ? new_sync_read+0x600/0x600   ? __fget_files+0x255/0x450   ? lock_downgrade+0x6e0/0x6e0   ? fput+0x30/0x1a0   ? ksys_write+0x1a8/0x260   __x64_sys_bpf+0x7a/0xc0   ? syscall_enter_from_user_mode+0x21/0x70   do_syscall_64+0x3b/0x90   entry_SYSCALL_64_after_hwframe+0x63/0xcd  RIP: 0033:0x7f917c4e2c2dThe problem here is that a range of tnum_range(0, map->max_entries - 1) haslimited ability to represent the concrete tight range with the tnum as theset of resulting states from value + mask can result in a superset of theactual intended range, and as such a tnum_in(range, reg->var_off) check mayyield true when it shouldn't, for example tnum_range(0, 2) would result in00XX -> v = 0000, m = 0011 such that the intended set of {0, 1, 2} is hererepresented by a less precise superset of {0, 1, 2, 3}. As the register isknown const scalar, really just use the concrete reg->var_off.value for theupper index check.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/ARPSyndicate/cve-scores

