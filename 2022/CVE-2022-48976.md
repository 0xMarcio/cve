### [CVE-2022-48976](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-48976)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5345d78ae64d5a760c211cd2da995dc71c5b29e4%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.0%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=b038177636f83bbf87c2b238706474145dd2cd04%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:netfilter: flowtable_offload: fix using __this_cpu_add in preemptibleflow_offload_queue_work() can be called in workqueue withoutbh disabled, like the call trace showed in my act_ct testing,calling NF_FLOW_TABLE_STAT_INC() there would cause a calltrace:  BUG: using __this_cpu_add() in preemptible [00000000] code: kworker/u4:0/138560  caller is flow_offload_queue_work+0xec/0x1b0 [nf_flow_table]  Workqueue: act_ct_workqueue tcf_ct_flow_table_cleanup_work [act_ct]  Call Trace:   <TASK>   dump_stack_lvl+0x33/0x46   check_preemption_disabled+0xc3/0xf0   flow_offload_queue_work+0xec/0x1b0 [nf_flow_table]   nf_flow_table_iterate+0x138/0x170 [nf_flow_table]   nf_flow_table_free+0x140/0x1a0 [nf_flow_table]   tcf_ct_flow_table_cleanup_work+0x2f/0x2b0 [act_ct]   process_one_work+0x6a3/0x1030   worker_thread+0x8a/0xdf0This patch fixes it by using NF_FLOW_TABLE_STAT_INC_ATOMIC()instead in flow_offload_queue_work().Note that for FLOW_CLS_REPLACE branch in flow_offload_queue_work(),it may not be called in preemptible path, but it's good to useNF_FLOW_TABLE_STAT_INC_ATOMIC() for all cases inflow_offload_queue_work().

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/ARPSyndicate/cve-scores

