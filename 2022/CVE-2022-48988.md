### [CVE-2022-48988](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-48988)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=3.14%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=347c4a8747104a945ecced358944e42879176ca5%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:memcg: fix possible use-after-free in memcg_write_event_control()memcg_write_event_control() accesses the dentry->d_name of the specifiedcontrol fd to route the write call.  As a cgroup interface file can't berenamed, it's safe to access d_name as long as the specified file is aregular cgroup file.  Also, as these cgroup interface files can't beremoved before the directory, it's safe to access the parent too.Prior to 347c4a874710 ("memcg: remove cgroup_event->cft"), there was acall to __file_cft() which verified that the specified file is a regularcgroupfs file before further accesses.  The cftype pointer returned from__file_cft() was no longer necessary and the commit inadvertently droppedthe file type check with it allowing any file to slip through.  With theinvarients broken, the d_name and parent accesses can now race againstrenames and removals of arbitrary files and cause use-after-free's.Fix the bug by resurrecting the file type check in __file_cft().  Now thatcgroupfs is implemented through kernfs, checking the file operations needsto go through a layer of indirection.  Instead, let's check the superblockand dentry type.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/ARPSyndicate/cve-scores

