### [CVE-2024-53190](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-53190)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=0c8173385e549f95cd80c3fff5aab87b4f881d8d%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=2.6.38%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:wifi: rtlwifi: Drastically reduce the attempts to read efuse in case of failuresSyzkaller reported a hung task with uevent_show() on stack trace. Thatspecific issue was addressed by another commit [0], but even with thatfix applied (for example, running v6.12-rc5) we face another type of hungtask that comes from the same reproducer [1]. By investigating that, wecould narrow it to the following path:(a) Syzkaller emulates a Realtek USB WiFi adapter using raw-gadget anddummy_hcd infrastructure.(b) During the probe of rtl8192cu, the driver ends-up performing an efuseread procedure (which is related to EEPROM load IIUC), and here lies theissue: the function read_efuse() calls read_efuse_byte() many times, asloop iterations depending on the efuse size (in our example, 512 in total).This procedure for reading efuse bytes relies in a loop that performs anI/O read up to *10k* times in case of failures. We measured the time ofthe loop inside read_efuse_byte() alone, and in this reproducer (whichinvolves the dummy_hcd emulation layer), it takes 15 seconds each. As aconsequence, we have the driver stuck in its probe routine for big time,exposing a stack trace like below if we attempt to reboot the system, forexample:task:kworker/0:3 state:D stack:0 pid:662 tgid:662 ppid:2 flags:0x00004000Workqueue: usb_hub_wq hub_eventCall Trace: __schedule+0xe22/0xeb6 schedule_timeout+0xe7/0x132 __wait_for_common+0xb5/0x12e usb_start_wait_urb+0xc5/0x1ef ? usb_alloc_urb+0x95/0xa4 usb_control_msg+0xff/0x184 _usbctrl_vendorreq_sync+0xa0/0x161 _usb_read_sync+0xb3/0xc5 read_efuse_byte+0x13c/0x146 read_efuse+0x351/0x5f0 efuse_read_all_map+0x42/0x52 rtl_efuse_shadow_map_update+0x60/0xef rtl_get_hwinfo+0x5d/0x1c2 rtl92cu_read_eeprom_info+0x10a/0x8d5 ? rtl92c_read_chip_version+0x14f/0x17e rtl_usb_probe+0x323/0x851 usb_probe_interface+0x278/0x34b really_probe+0x202/0x4a4 __driver_probe_device+0x166/0x1b2 driver_probe_device+0x2f/0xd8 [...]We propose hereby to drastically reduce the attempts of doing the I/Oreads in case of failures, restricted to USB devices (given thatthey're inherently slower than PCIe ones). By retrying up to 10 times(instead of 10000), we got reponsiveness in the reproducer, while seemsreasonable to believe that there's no sane USB device implementation inthe field requiring this amount of retries at every I/O read in orderto properly work. Based on that assumption, it'd be good to have itbackported to stable but maybe not since driver implementation (the 10knumber comes from day 0), perhaps up to 6.x series makes sense.[0] Commit 15fffc6a5624 ("driver core: Fix uevent_show() vs driver detach race")[1] A note about that: this syzkaller report presents multiple reproducersthat differs by the type of emulated USB device. For this specific case,check the entry from 2024/08/08 06:23 in the list of crashes; the C reprois available at https://syzkaller.appspot.com/text?tag=ReproC&x=1521fc83980000.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

