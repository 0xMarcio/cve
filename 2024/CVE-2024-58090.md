### [CVE-2024-58090](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-58090)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:sched/core: Prevent rescheduling when interrupts are disabledDavid reported a warning observed while loop testing kexec jump:  Interrupts enabled after irqrouter_resume+0x0/0x50  WARNING: CPU: 0 PID: 560 at drivers/base/syscore.c:103 syscore_resume+0x18a/0x220   kernel_kexec+0xf6/0x180   __do_sys_reboot+0x206/0x250   do_syscall_64+0x95/0x180The corresponding interrupt flag trace:  hardirqs last  enabled at (15573): [<ffffffffa8281b8e>] __up_console_sem+0x7e/0x90  hardirqs last disabled at (15580): [<ffffffffa8281b73>] __up_console_sem+0x63/0x90That means __up_console_sem() was invoked with interrupts enabled. Furtherinstrumentation revealed that in the interrupt disabled section of kexecjump one of the syscore_suspend() callbacks woke up a task, which set theNEED_RESCHED flag. A later callback in the resume path invokedcond_resched() which in turn led to the invocation of the scheduler:  __cond_resched+0x21/0x60  down_timeout+0x18/0x60  acpi_os_wait_semaphore+0x4c/0x80  acpi_ut_acquire_mutex+0x3d/0x100  acpi_ns_get_node+0x27/0x60  acpi_ns_evaluate+0x1cb/0x2d0  acpi_rs_set_srs_method_data+0x156/0x190  acpi_pci_link_set+0x11c/0x290  irqrouter_resume+0x54/0x60  syscore_resume+0x6a/0x200  kernel_kexec+0x145/0x1c0  __do_sys_reboot+0xeb/0x240  do_syscall_64+0x95/0x180This is a long standing problem, which probably got more visible withthe recent printk changes. Something does a task wakeup and thescheduler sets the NEED_RESCHED flag. cond_resched() sees it set andinvokes schedule() from a completely bogus context. The schedulerenables interrupts after context switching, which causes the abovewarning at the end.Quite some of the code paths in syscore_suspend()/resume() can result intriggering a wakeup with the exactly same consequences. They might nothave done so yet, but as they share a lot of code with normal operationsit's just a question of time.The problem only affects the PREEMPT_NONE and PREEMPT_VOLUNTARY schedulingmodels. Full preemption is not affected as cond_resched() is disabled andthe preemption check preemptible() takes the interrupt disabled flag intoaccount.Cure the problem by adding a corresponding check into cond_resched().

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

