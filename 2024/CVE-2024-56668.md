### [CVE-2024-56668](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-56668)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=705c1cdf1e73c4c727bbfc8775434e6dd36e8baf%3C%20ffd774c34774fd4cc0e9cf2976595623a6c3a077%20&color=brighgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=brighgreen)

### Description

In the Linux kernel, the following vulnerability has been resolved:iommu/vt-d: Fix qi_batch NULL pointer with nested parent domainThe qi_batch is allocated when assigning cache tag for a domain. Whilefor nested parent domain, it is missed. Hence, when trying to map pagesto the nested parent, NULL dereference occurred. Also, there is potentialmemleak since there is no lock around domain->qi_batch allocation.To solve it, add a helper for qi_batch allocation, and call it in boththe __cache_tag_assign_domain() and __cache_tag_assign_parent_domain().  BUG: kernel NULL pointer dereference, address: 0000000000000200  #PF: supervisor read access in kernel mode  #PF: error_code(0x0000) - not-present page  PGD 8104795067 P4D 0  Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI  CPU: 223 UID: 0 PID: 4357 Comm: qemu-system-x86 Not tainted 6.13.0-rc1-00028-g4b50c3c3b998-dirty #2632  Call Trace:   ? __die+0x24/0x70   ? page_fault_oops+0x80/0x150   ? do_user_addr_fault+0x63/0x7b0   ? exc_page_fault+0x7c/0x220   ? asm_exc_page_fault+0x26/0x30   ? cache_tag_flush_range_np+0x13c/0x260   intel_iommu_iotlb_sync_map+0x1a/0x30   iommu_map+0x61/0xf0   batch_to_domain+0x188/0x250   iopt_area_fill_domains+0x125/0x320   ? rcu_is_watching+0x11/0x50   iopt_map_pages+0x63/0x100   iopt_map_common.isra.0+0xa7/0x190   iopt_map_user_pages+0x6a/0x80   iommufd_ioas_map+0xcd/0x1d0   iommufd_fops_ioctl+0x118/0x1c0   __x64_sys_ioctl+0x93/0xc0   do_syscall_64+0x71/0x140   entry_SYSCALL_64_after_hwframe+0x76/0x7e

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/cku-heise/euvd-api-doc

