### [CVE-2024-49878](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-49878)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5.1%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=c221c0b0308fd01d9fb33a16f64d2fd95f8830a4%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:resource: fix region_intersects() vs add_memory_driver_managed()On a system with CXL memory, the resource tree (/proc/iomem) related toCXL memory may look like something as follows.490000000-50fffffff : CXL Window 0  490000000-50fffffff : region0    490000000-50fffffff : dax0.0      490000000-50fffffff : System RAM (kmem)Because drivers/dax/kmem.c calls add_memory_driver_managed() duringonlining CXL memory, which makes "System RAM (kmem)" a descendant of "CXLWindow X".  This confuses region_intersects(), which expects all "SystemRAM" resources to be at the top level of iomem_resource.  This can lead tobugs.For example, when the following command line is executed to write somememory in CXL memory range via /dev/mem, $ dd if=data of=/dev/mem bs=$((1 << 10)) seek=$((0x490000000 >> 10)) count=1 dd: error writing '/dev/mem': Bad address 1+0 records in 0+0 records out 0 bytes copied, 0.0283507 s, 0.0 kB/sthe command fails as expected.  However, the error code is wrong.  Itshould be "Operation not permitted" instead of "Bad address".  Moreseriously, the /dev/mem permission checking in devmem_is_allowed() passesincorrectly.  Although the accessing is prevented later because ioremap()isn't allowed to map system RAM, it is a potential security issue.  Duringcommand executing, the following warning is reported in the kernel log forcalling ioremap() on system RAM. ioremap on RAM at 0x0000000490000000 - 0x0000000490000fff WARNING: CPU: 2 PID: 416 at arch/x86/mm/ioremap.c:216 __ioremap_caller.constprop.0+0x131/0x35d Call Trace:  memremap+0xcb/0x184  xlate_dev_mem_ptr+0x25/0x2f  write_mem+0x94/0xfb  vfs_write+0x128/0x26d  ksys_write+0xac/0xfe  do_syscall_64+0x9a/0xfd  entry_SYSCALL_64_after_hwframe+0x4b/0x53The details of command execution process are as follows.  In the aboveresource tree, "System RAM" is a descendant of "CXL Window 0" instead of atop level resource.  So, region_intersects() will report no System RAMresources in the CXL memory region incorrectly, because it only checks thetop level resources.  Consequently, devmem_is_allowed() will return 1(allow access via /dev/mem) for CXL memory region incorrectly. Fortunately, ioremap() doesn't allow to map System RAM and reject theaccess.So, region_intersects() needs to be fixed to work correctly with theresource tree with "System RAM" not at top level as above.  To fix it, ifwe found a unmatched resource in the top level, we will continue to searchmatched resources in its descendant resources.  So, we will not miss anymatched resources in resource tree anymore.In the new implementation, an example resource tree|------------- "CXL Window 0" ------------||-- "System RAM" --|will behave similar as the following fake resource tree forregion_intersects(, IORESOURCE_SYSTEM_RAM, ),|-- "System RAM" --||-- "CXL Window 0a" --|Where "CXL Window 0a" is part of the original "CXL Window 0" thatisn't covered by "System RAM".

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

