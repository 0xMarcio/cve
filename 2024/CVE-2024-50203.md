### [CVE-2024-50203](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-50203)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=077149478497b2f00ff4fd9da2c892defa6418d8%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=19d3c179a37730caf600a97fed3794feac2b197b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.11%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6d218fcc707d6b2c3616b6cd24b948fd4825cfec%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=d9664e6ff040798a46cdc5d401064f55b8676c83%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:bpf, arm64: Fix address emission with tag-based KASAN enabledWhen BPF_TRAMP_F_CALL_ORIG is enabled, the address of a bpf_tramp_imagestruct on the stack is passed during the size calculation pass andan address on the heap is passed during code generation. This maycause a heap buffer overflow if the heap address is tagged becauseemit_a64_mov_i64() will emit longer code than it did during the sizecalculation pass. The same problem could occur without tag-basedKASAN if one of the 16-bit words of the stack address happened tobe all-ones during the size calculation pass. Fix the problem byassuming the worst case (4 instructions) when calculating the sizeof the bpf_tramp_image address emission.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds

