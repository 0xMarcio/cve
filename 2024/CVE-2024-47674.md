### [CVE-2024-47674](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47674)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:mm: avoid leaving partial pfn mappings around in error caseAs Jann points out, PFN mappings are special, because unlike normalmemory mappings, there is no lifetime information associated with themapping - it is just a raw mapping of PFNs with no reference counting ofa 'struct page'.That's all very much intentional, but it does mean that it's easy tomess up the cleanup in case of errors.  Yes, a failed mmap() will alwayseventually clean up any partial mappings, but without any explicitlifetime in the page table mapping itself, it's very easy to do theerror handling in the wrong order.In particular, it's easy to mistakenly free the physical backing storebefore the page tables are actually cleaned up and (temporarily) havestale dangling PTE entries.To make this situation less error-prone, just make sure that any partialpfn mapping is torn down early, before any other error handling.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds
- https://github.com/w4zu/Debian_security

