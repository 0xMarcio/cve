### [CVE-2024-50099](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-50099)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.10%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=9842ceae9fa8deae141533d52a6ead7666962c09%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:arm64: probes: Remove broken LDR (literal) uprobe supportThe simulate_ldr_literal() and simulate_ldrsw_literal() functions areunsafe to use for uprobes. Both functions were originally written foruse with kprobes, and access memory with plain C accesses. When uprobeswas added, these were reused unmodified even though they cannot safelyaccess user memory.There are three key problems:1) The plain C accesses do not have corresponding extable entries, and   thus if they encounter a fault the kernel will treat these as   unintentional accesses to user memory, resulting in a BUG() which   will kill the kernel thread, and likely lead to further issues (e.g.   lockup or panic()).2) The plain C accesses are subject to HW PAN and SW PAN, and so when   either is in use, any attempt to simulate an access to user memory   will fault. Thus neither simulate_ldr_literal() nor   simulate_ldrsw_literal() can do anything useful when simulating a   user instruction on any system with HW PAN or SW PAN.3) The plain C accesses are privileged, as they run in kernel context,   and in practice can access a small range of kernel virtual addresses.   The instructions they simulate have a range of +/-1MiB, and since the   simulated instructions must itself be a user instructions in the   TTBR0 address range, these can address the final 1MiB of the TTBR1   acddress range by wrapping downwards from an address in the first   1MiB of the TTBR0 address range.   In contemporary kernels the last 8MiB of TTBR1 address range is   reserved, and accesses to this will always fault, meaning this is no   worse than (1).   Historically, it was theoretically possible for the linear map or   vmemmap to spill into the final 8MiB of the TTBR1 address range, but   in practice this is extremely unlikely to occur as this would   require either:   * Having enough physical memory to fill the entire linear map all the     way to the final 1MiB of the TTBR1 address range.   * Getting unlucky with KASLR randomization of the linear map such     that the populated region happens to overlap with the last 1MiB of     the TTBR address range.   ... and in either case if we were to spill into the final page there   would be larger problems as the final page would alias with error   pointers.Practically speaking, (1) and (2) are the big issues. Given there havebeen no reports of problems since the broken code was introduced, itappears that no-one is relying on probing these instructions withuprobes.Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW(literal), limiting the use of simulate_ldr_literal() andsimulate_ldrsw_literal() to kprobes. Attempts to place uprobes on LDR(literal) and LDRSW (literal) will be rejected asarm_probe_decode_insn() will return INSN_REJECTED. In future we canconsider introducing working uprobes support for these instructions, butthis will require more significant work.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

