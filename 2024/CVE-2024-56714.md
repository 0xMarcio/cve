### [CVE-2024-56714](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-56714)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6.11%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=9e25450da7006cd6f425248a5b38dad4adb3c981%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:ionic: no double destroy workqueueThere are some FW error handling paths that can cause us totry to destroy the workqueue more than once, so let's be surewe're checking for that.The case where this popped up was in an AER event where thehandlers got called in such a way that ionic_reset_prepare()and thus ionic_dev_teardown() got called twice in a row.The second time through the workqueue was already destroyed,and destroy_workqueue() choked on the bad wq pointer.We didn't hit this in AER handler testing before because atthat time we weren't using a private workqueue.  Later wereplaced the use of the system workqueue with our own privateworkqueue but hadn't rerun the AER handler testing since then.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/cku-heise/euvd-api-doc
- https://github.com/fkie-cad/nvd-json-data-feeds

